#!/usr/bin/python
from gpiozero.exc import *
from gpiozero import Button
import os
import time
import sys
import configparser
import string
##
# EDIT IF NEEDED
##
channels=[
          "SHEET@1NR","SHEET@1FR",
          "SHEET@2NR","SHEET@2FR",
          "SHEET@3NR","SHEET@3FR",
          "SHEET@4NR","SHEET@4FR",
          "SHEET@5NR","SHEET@5FR",
          "SHEET@6NR","SHEET@6FR",
          "SHEET@W1_3FR", "SHEET@W1_3NR", 
          "SHEET@W4_6FR", "SHEET@W4_6NR",
          "SIDEBYSIDE@1","SIDEBYSIDE@2","SIDEBYSIDE@3",
          "SIDEBYSIDE@4","SIDEBYSIDE@5","SIDEBYSIDE@6"
         ]
fifo_path="/tmp/cameractl.fifo"

# GPIO Button pins
# Ref: https://gpiozero.readthedocs.io/en/stable/recipes.html#pin-numbering
# up: GPIO17  down: GPIO27
try:
  print("GPIO17 -> UP")
  ubtn=Button(17)
  print(ubtn)
  print("GPIO27 -> DOWN")
  dbtn=Button(27)
  print(dbtn)
  sys.stdout.flush()
except BadPinFactory:
  print("WARNING: Cannot find GPIO pins, disabling GPIO button support")
  sys.stdout.flush()
  ubtn=None
  dbtn=None
ubtn_held=False
bbtn_held=False



##################################
##
#  DO NOT EDIT BEYOND THIS POINT
##
##################################
config = configparser.ConfigParser()
config['DEFAULT']={'channel':'SHEET@1NR'}

config.read('/etc/omxplayer/camera_control.ini')
default_channel = config['DEFAULT']['channel']
try:
  default_index = channels.index(default_channel)
except:
  default_index = 0

num_channels=len(channels)
current_channel=default_index
print(current_channel)
print(channels[current_channel])

def flush_fifo(f):
  print("flushing fifo")
  sys.stdout.flush()
  d=f.read()
  while len(d) > 0 :
    d=f.read()
  print("done flushing fifo")
  sys.stdout.flush()

def set_dbtn_held(value):
    global dbtn_held
    dbtn_held=value
    print("Setting dbtn_held:",dbtn_held)
def set_ubtn_held(value):
    global ubtn_held
    ubtn_held=value
    print("Setting ubtn_held:",ubtn_held)

def down_btn_pressed():
    print("Caught Down Button Press") 
    set_dbtn_held(False)

def down_btn_released():
    global current_channel
    print("Caught Down Button Release") 
    print(ubtn)
    print(dbtn)
    sys.stdout.flush()
    if dbtn_held:
      print("Down Button Long Press Detected, Ignoring Release Event",dbtn_held) 
    else:
      current_channel=channel_down(True)

def down_btn_held():
    global current_channel
    print("Caught Down Button Long Hold")
    set_dbtn_held(True)
    print(ubtn)
    print(dbtn)
    sys.stdout.flush()
    current_channel=channel_jump(default_index)

def up_btn_pressed():
    print("Caught Up Button Press") 
    set_ubtn_held(False)

def up_btn_released():
    global current_channel
    print("Caught Up Button Release") 
    print(ubtn)
    print(dbtn)
    sys.stdout.flush()
    if ubtn_held:
      print("Up Button Long Press Detected, Ignoring Release Event",ubtn_held) 
    else:
      current_channel=channel_up(True)

def up_btn_held():
    global current_channel
    print("Caught Up Button Long Hold") 
    set_ubtn_held(True)
    print(ubtn)
    print(dbtn)
    sys.stdout.flush()
    current_channel=channel_jump(default_index)

def activate_channel(cnum):
  print("Activating {}".format(channels[cnum]))
  sys.stdout.flush()
  retval=os.system("sudo -n systemctl restart {}".format(channels[cnum]))
  return retval

def channel_up(skip_broken=False):
  global current_channel
  start_channel=current_channel
  next_channel=start_channel 
  attempt=0
  while attempt < 20:
    attempt=attempt+1
    next_channel=(next_channel+1) % num_channels
    retval=activate_channel(next_channel)
    if skip_broken:
      if next_channel==start_channel: break
      else:
        if retval==0: break
        else:
          print("Skipping broken channel {}".format(channels[next_channel])) 
          continue  
    else: break
  if retval == 0: 
    print("chan Up: {}:{} -> {}:{}".format(current_channel,channels[current_channel],next_channel,channels[next_channel]))
    sys.stdout.flush()
    return next_channel
  else:
    print("ERROR: chan Up: {}:{} -> {}:{}".format(current_channel,channels[current_channel],next_channel,channels[next_channel]))
    sys.stdout.flush()
    return current_channel

def channel_down(skip_broken=False):
  global current_channel
  start_channel=current_channel
  next_channel=start_channel 
  attempt=0
  while attempt < 20:
    attempt=attempt+1
    next_channel=(next_channel-1) % num_channels
    retval=activate_channel(next_channel)
    if skip_broken:
      if next_channel == start_channel: break
      else:
        if retval == 0: break
        else:   
          print("Skipping broken channel {}".format(channels[next_channel])) 
          continue  
    else: break
  if retval == 0: 
    print("chan Down: {}:{} -> {}:{}".format(current_channel,channels[current_channel],next_channel,channels[next_channel]))
    sys.stdout.flush()
    return next_channel
  else:
    print("ERROR: chan Down: {}:{} -> {}:{}".format(current_channel,channels[current_channel],next_channel,channels[next_channel]))
    sys.stdout.flush()
    return current_channel
  return next_channel

def channel_jump(requested_channel=None):
  global current_channel
  if requested_channel:
    retval=activate_channel(requested_channel)
    if retval == 0: 
      print("chan Jump: {}:{} -> {}:{}".format(current_channel,channels[current_channel],requested_channel,channels[requested_channel]))
      sys.stdout.flush()
      return requested_channel
    else:
      print("ERROR: chan Jump: {}:{} -> {}:{}".format(current_channel,channels[current_channel],requested_channel,channels[requested_channel]))
      sys.stdout.flush()
      return current_channel
  return current_channel


if os.path.exists(fifo_path): os.remove(fifo_path) 

os.mkfifo(fifo_path)
fd=os.open(fifo_path,os.O_RDONLY | os.O_NONBLOCK)
fifo=os.fdopen(fd)
##
# TODO: Select startup channel from argument 
##

retval=os.system("sudo -n fbi --noverbose -a -T 1 /etc/omxplayer/back.png")
retval=activate_channel(current_channel)

if ubtn: 
    ubtn.when_released=up_btn_released
    ubtn.when_pressed=up_btn_pressed
    ubtn.when_held=up_btn_held
    ubtn.hold_time=2
    ubtn_pressed=False
if dbtn: 
    dbtn.when_released=down_btn_released
    dbtn.when_pressed=down_btn_pressed
    dbtn.when_held=down_btn_held
    dbtn.hold_time=2
    dbtn_pressed=False

print("Entering fifo wait loop")
sys.stdout.flush()
while True:
  data = fifo.readline()
  if data  == "": 
    time.sleep(0.1)
    continue

  if data[0].upper()=='U': 
    print("fifo UP command recv'd")
    print(ubtn)
    print(dbtn)
    sys.stdout.flush()
    current_channel=channel_up(True)
    flush_fifo(fifo)
    time.sleep(1) 
    continue

  if data[0].upper()=='D':
    print("fifo DOWN command recv'd")
    print(ubtn)
    print(dbtn)
    sys.stdout.flush()
    current_channel=channel_down(True) 
    flush_fifo(fifo)
    time.sleep(1)
    continue

  if data[0].upper()=='B':
    print("fifo BUTTON command recv'd")
    for x in range(28):
      if x == 17: print(ubtn)
      else:
        if x == 27: print(dbtn)
        else: print(Button(x))
    sys.stdout.flush()
    flush_fifo(fifo)
    time.sleep(1)
    continue

  if data[0].upper()=='^':
    segments=string.split(data,'^')
    chan=string.strip(segments[1])
    try:
      chan_index = channels.index(chan)
      print("Jump to channel: {}".format(chan))
      retval=activate_channel(chan_index)
      if retval == 0:
          current_channel=chan_index
      else:
          retval=activate_channel(current_channel)
          print("Abort Jump: Channel Activate Failed: {}".format(chan))
          
    except:
      print("Abort Jump: Channel Not Found: {}".format(chan))

print("done")
sys.stdout.flush()
fifo.close()
